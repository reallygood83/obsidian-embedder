/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DriveEmbedderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  // Google OAuth
  googleClientId: "",
  googleClientSecret: "",
  googleAccessToken: "",
  googleRefreshToken: "",
  tokenExpiresAt: 0,
  // Drive settings
  driveFolder: "Obsidian/DriveEmbedder",
  // Embed settings
  showTitleByDefault: true,
  defaultTheme: "auto",
  // Default sizes per category
  defaultVideoSize: "medium",
  defaultDocumentSize: "medium",
  defaultImageSize: "medium",
  defaultAudioSize: "slim"
};

// src/google-oauth-flow.ts
var import_obsidian = require("obsidian");
var http = __toESM(require("http"));
var url = __toESM(require("url"));
var GoogleOAuthFlow = class {
  constructor(config) {
    this.AUTH_URL = "https://accounts.google.com/o/oauth2/v2/auth";
    this.TOKEN_URL = "https://oauth2.googleapis.com/token";
    this.SCOPES = [
      "https://www.googleapis.com/auth/drive.file",
      "https://www.googleapis.com/auth/userinfo.email"
    ];
    this.server = null;
    this.config = config;
  }
  /**
   * Start the OAuth flow - opens browser and waits for callback
   */
  async startOAuthFlow() {
    return new Promise(async (resolve, reject) => {
      try {
        const codeVerifier = this.generateCodeVerifier();
        const codeChallenge = await this.generateCodeChallenge(codeVerifier);
        const redirectUri = `http://localhost:${this.config.redirectPort}/callback`;
        this.server = http.createServer(async (req, res) => {
          try {
            const parsedUrl = url.parse(req.url || "", true);
            if (parsedUrl.pathname === "/callback") {
              const code = parsedUrl.query.code;
              const error = parsedUrl.query.error;
              if (error) {
                res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
                res.end(this.getErrorHtml(error));
                this.cleanup();
                reject(new Error(`OAuth error: ${error}`));
                return;
              }
              if (code) {
                try {
                  const tokens = await this.exchangeCodeForTokens(code, codeVerifier, redirectUri);
                  res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
                  res.end(this.getSuccessHtml());
                  this.cleanup();
                  resolve(tokens);
                } catch (tokenError) {
                  res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
                  res.end(this.getErrorHtml(tokenError.message));
                  this.cleanup();
                  reject(tokenError);
                }
              }
            }
          } catch (err) {
            reject(err);
          }
        });
        this.server.listen(this.config.redirectPort, () => {
          console.log(`OAuth callback server listening on port ${this.config.redirectPort}`);
        });
        this.server.on("error", (err) => {
          if (err.code === "EADDRINUSE") {
            reject(new Error(`Port ${this.config.redirectPort} is already in use. Please close other applications using this port.`));
          } else {
            reject(err);
          }
        });
        const authUrl = this.buildAuthUrl(redirectUri, codeChallenge);
        new import_obsidian.Notice("Please log in with Google in your browser...", 3e3);
        const { shell } = require("electron");
        shell.openExternal(authUrl);
        setTimeout(() => {
          if (this.server) {
            this.cleanup();
            reject(new Error("OAuth flow timed out. Please try again."));
          }
        }, 12e4);
      } catch (error) {
        this.cleanup();
        reject(error);
      }
    });
  }
  /**
   * Refresh access token using refresh token
   */
  async refreshAccessToken(refreshToken) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: this.TOKEN_URL,
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          client_id: this.config.clientId,
          client_secret: this.config.clientSecret,
          refresh_token: refreshToken,
          grant_type: "refresh_token"
        }).toString()
      });
      if (response.status !== 200) {
        throw new Error(`Token refresh failed: ${response.status}`);
      }
      const data = response.json;
      const expiresAt = Date.now() + data.expires_in * 1e3;
      return {
        accessToken: data.access_token,
        refreshToken,
        // Refresh token doesn't change
        expiresIn: data.expires_in,
        expiresAt
      };
    } catch (error) {
      console.error("Token refresh error:", error);
      throw new Error(`Failed to refresh token: ${error.message}`);
    }
  }
  /**
   * Check if token is expired or about to expire (within 5 minutes)
   */
  isTokenExpired(expiresAt) {
    const bufferTime = 5 * 60 * 1e3;
    return Date.now() >= expiresAt - bufferTime;
  }
  /**
   * Exchange authorization code for tokens
   */
  async exchangeCodeForTokens(code, codeVerifier, redirectUri) {
    const response = await (0, import_obsidian.requestUrl)({
      url: this.TOKEN_URL,
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: new URLSearchParams({
        code,
        client_id: this.config.clientId,
        client_secret: this.config.clientSecret,
        redirect_uri: redirectUri,
        grant_type: "authorization_code",
        code_verifier: codeVerifier
      }).toString()
    });
    if (response.status !== 200) {
      throw new Error(`Token exchange failed: ${response.status}`);
    }
    const data = response.json;
    const expiresAt = Date.now() + data.expires_in * 1e3;
    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_in,
      expiresAt
    };
  }
  /**
   * Build OAuth authorization URL
   */
  buildAuthUrl(redirectUri, codeChallenge) {
    const params = new URLSearchParams({
      client_id: this.config.clientId,
      redirect_uri: redirectUri,
      response_type: "code",
      scope: this.SCOPES.join(" "),
      access_type: "offline",
      prompt: "consent",
      code_challenge: codeChallenge,
      code_challenge_method: "S256"
    });
    return `${this.AUTH_URL}?${params.toString()}`;
  }
  /**
   * Generate random code verifier for PKCE
   */
  generateCodeVerifier() {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return this.base64UrlEncode(array);
  }
  /**
   * Generate code challenge from verifier
   */
  async generateCodeChallenge(verifier) {
    const encoder = new TextEncoder();
    const data = encoder.encode(verifier);
    const hash = await crypto.subtle.digest("SHA-256", data);
    return this.base64UrlEncode(new Uint8Array(hash));
  }
  /**
   * Base64 URL encode
   */
  base64UrlEncode(buffer) {
    let binary = "";
    for (let i = 0; i < buffer.length; i++) {
      binary += String.fromCharCode(buffer[i]);
    }
    return btoa(binary).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  /**
   * Cleanup server
   */
  cleanup() {
    if (this.server) {
      this.server.close();
      this.server = null;
    }
  }
  /**
   * Success HTML page
   */
  getSuccessHtml() {
    return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Google Drive Connection Complete</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #4285f4 0%, #34a853 100%);
        }
        .container {
            background: white;
            padding: 40px 60px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        .success-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        p {
            color: #666;
            margin-bottom: 20px;
        }
        .close-hint {
            font-size: 14px;
            color: #999;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="success-icon">\u2705</div>
        <h1>Connection Complete!</h1>
        <p>Google Drive has been connected to Drive Embedder.</p>
        <p class="close-hint">You can close this window and return to Obsidian.</p>
    </div>
</body>
</html>
        `;
  }
  /**
   * Error HTML page
   */
  getErrorHtml(error) {
    return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Connection Failed</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #ea4335 0%, #fbbc05 100%);
        }
        .container {
            background: white;
            padding: 40px 60px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        .error-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        p {
            color: #666;
            margin-bottom: 20px;
        }
        .error-detail {
            background: #fff3f3;
            border: 1px solid #ffcccc;
            padding: 10px 20px;
            border-radius: 8px;
            color: #cc0000;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="error-icon">\u274C</div>
        <h1>Connection Failed</h1>
        <p>Failed to connect to Google Drive.</p>
        <div class="error-detail">${error}</div>
        <p>Please try again in Obsidian.</p>
    </div>
</body>
</html>
        `;
  }
};

// src/uploader.ts
var import_obsidian2 = require("obsidian");
var GoogleDriveUploader = class {
  constructor(config) {
    this.API_URL = "https://www.googleapis.com/drive/v3";
    this.UPLOAD_URL = "https://www.googleapis.com/upload/drive/v3";
    this.REDIRECT_PORT = 8586;
    this.config = config;
    this.oauthFlow = new GoogleOAuthFlow({
      clientId: config.clientId,
      clientSecret: config.clientSecret,
      redirectPort: this.REDIRECT_PORT
    });
  }
  /**
   * Start OAuth flow to connect Google Drive
   */
  async connectGoogleDrive() {
    return this.oauthFlow.startOAuthFlow();
  }
  /**
   * Check if connected to Google Drive
   */
  isConnected() {
    return !!(this.config.accessToken && this.config.refreshToken);
  }
  /**
   * Ensure we have a valid access token, refreshing if necessary
   */
  async ensureValidToken() {
    if (this.config.tokenExpiresAt && this.config.refreshToken) {
      if (this.oauthFlow.isTokenExpired(this.config.tokenExpiresAt)) {
        console.log("Access token expired, refreshing...");
        try {
          const newTokens = await this.oauthFlow.refreshAccessToken(this.config.refreshToken);
          this.config.accessToken = newTokens.accessToken;
          this.config.tokenExpiresAt = newTokens.expiresAt;
          if (this.config.onTokenRefresh) {
            await this.config.onTokenRefresh(newTokens);
          }
          new import_obsidian2.Notice("Google Drive token automatically refreshed");
        } catch (error) {
          console.error("Token refresh failed:", error);
          throw new Error("Token refresh failed. Please reconnect Google Drive.");
        }
      }
    }
    if (!this.config.accessToken) {
      throw new Error("Not connected to Google Drive. Please connect first.");
    }
    return this.config.accessToken;
  }
  /**
   * Upload a file to Google Drive with progress callback
   */
  async uploadFile(file, folderPath, onProgress) {
    try {
      onProgress == null ? void 0 : onProgress({
        stage: "preparing",
        message: "Preparing upload...",
        progress: 10
      });
      const accessToken = await this.ensureValidToken();
      const folderId = await this.ensureFolder(folderPath);
      const arrayBuffer = await file.arrayBuffer();
      const base64Content = this.arrayBufferToBase64(arrayBuffer);
      onProgress == null ? void 0 : onProgress({
        stage: "uploading",
        message: "Uploading to Google Drive...",
        progress: 30
      });
      const metadata = {
        name: file.name,
        mimeType: file.type,
        parents: [folderId]
      };
      const boundary = "-------314159265358979323846";
      const delimiter = `\r
--${boundary}\r
`;
      const closeDelimiter = `\r
--${boundary}--`;
      const multipartBody = delimiter + "Content-Type: application/json\r\n\r\n" + JSON.stringify(metadata) + delimiter + `Content-Type: ${file.type}\r
Content-Transfer-Encoding: base64\r
\r
` + base64Content + closeDelimiter;
      const uploadResponse = await (0, import_obsidian2.requestUrl)({
        url: `${this.UPLOAD_URL}/files?uploadType=multipart&fields=id,webViewLink,webContentLink,name,mimeType`,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Content-Type": `multipart/related; boundary=${boundary}`
        },
        body: multipartBody
      });
      if (uploadResponse.status !== 200) {
        throw new Error(`Upload failed: ${uploadResponse.status}`);
      }
      const fileData = uploadResponse.json;
      const fileId = fileData.id;
      onProgress == null ? void 0 : onProgress({
        stage: "setting-permission",
        message: "Setting public access...",
        progress: 70
      });
      await this.makeFilePublic(fileId);
      const fileInfo = await this.getFileInfo(fileId);
      onProgress == null ? void 0 : onProgress({
        stage: "complete",
        message: "Upload complete!",
        progress: 100
      });
      return {
        fileId,
        webViewLink: fileInfo.webViewLink || `https://drive.google.com/file/d/${fileId}/view`,
        webContentLink: fileInfo.webContentLink || `https://drive.google.com/uc?export=view&id=${fileId}`,
        fileName: file.name,
        mimeType: file.type
      };
    } catch (error) {
      console.error("Error uploading to Google Drive:", error);
      onProgress == null ? void 0 : onProgress({
        stage: "error",
        message: "Upload failed",
        progress: 0,
        error: error.message
      });
      return null;
    }
  }
  /**
   * Make a file publicly accessible
   */
  async makeFilePublic(fileId) {
    try {
      const accessToken = await this.ensureValidToken();
      await (0, import_obsidian2.requestUrl)({
        url: `${this.API_URL}/files/${fileId}/permissions`,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          role: "reader",
          type: "anyone"
        })
      });
    } catch (error) {
      console.error("Failed to make file public:", error);
    }
  }
  /**
   * Get file info from Google Drive
   */
  async getFileInfo(fileId) {
    try {
      const accessToken = await this.ensureValidToken();
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${this.API_URL}/files/${fileId}?fields=webViewLink,webContentLink`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${accessToken}`
        }
      });
      return response.json;
    } catch (error) {
      return {};
    }
  }
  /**
   * Ensure folder exists, creating if necessary
   */
  async ensureFolder(folderPath) {
    const parts = folderPath.split("/").filter((p) => p.length > 0);
    let parentId = "root";
    for (const folderName of parts) {
      const existingId = await this.findFolder(folderName, parentId);
      if (existingId) {
        parentId = existingId;
      } else {
        parentId = await this.createFolder(folderName, parentId);
      }
    }
    return parentId;
  }
  /**
   * Find a folder by name
   */
  async findFolder(name, parentId) {
    try {
      const accessToken = await this.ensureValidToken();
      const query = `name='${name}' and '${parentId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`;
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${this.API_URL}/files?q=${encodeURIComponent(query)}&fields=files(id)`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${accessToken}`
        }
      });
      if (response.status === 200) {
        const data = response.json;
        if (data.files && data.files.length > 0) {
          return data.files[0].id;
        }
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  /**
   * Create a new folder
   */
  async createFolder(name, parentId) {
    const accessToken = await this.ensureValidToken();
    const metadata = {
      name,
      mimeType: "application/vnd.google-apps.folder",
      parents: [parentId]
    };
    const response = await (0, import_obsidian2.requestUrl)({
      url: `${this.API_URL}/files`,
      method: "POST",
      headers: {
        "Authorization": `Bearer ${accessToken}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(metadata)
    });
    if (response.status !== 200) {
      throw new Error(`Folder creation failed: ${response.status}`);
    }
    return response.json.id;
  }
  /**
   * Test the connection
   */
  async testConnection() {
    try {
      const accessToken = await this.ensureValidToken();
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${this.API_URL}/about?fields=user`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${accessToken}`
        }
      });
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }
  /**
   * Get user info
   */
  async getUserInfo() {
    try {
      const accessToken = await this.ensureValidToken();
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${this.API_URL}/about?fields=user`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${accessToken}`
        }
      });
      if (response.status === 200) {
        const data = response.json;
        return {
          email: data.user.emailAddress,
          name: data.user.displayName
        };
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  /**
   * Disconnect from Google Drive
   */
  disconnect() {
    this.config.accessToken = "";
    this.config.refreshToken = "";
    this.config.tokenExpiresAt = 0;
  }
  /**
   * Convert ArrayBuffer to base64
   */
  arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.length; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
};

// src/upload-modal.ts
var import_obsidian3 = require("obsidian");

// src/size-presets.ts
var SIZE_PRESETS = {
  video: [
    {
      id: "compact",
      label: "Compact",
      icon: "\u{1F539}",
      description: "Good for inline content",
      width: "60%",
      height: "280px"
    },
    {
      id: "medium",
      label: "Medium",
      icon: "\u{1F538}",
      description: "Recommended for most use cases",
      width: "80%",
      height: "400px",
      recommended: true
    },
    {
      id: "large",
      label: "Large",
      icon: "\u{1F536}",
      description: "For detailed viewing",
      width: "100%",
      height: "500px"
    },
    {
      id: "fullwidth",
      label: "Full Width",
      icon: "\u{1F7E0}",
      description: "Immersive viewing experience",
      width: "100%",
      height: "600px"
    }
  ],
  document: [
    {
      id: "compact",
      label: "Compact",
      icon: "\u{1F539}",
      description: "Quick preview",
      width: "70%",
      height: "400px"
    },
    {
      id: "medium",
      label: "Medium",
      icon: "\u{1F538}",
      description: "Good for reading documents",
      width: "100%",
      height: "500px",
      recommended: true
    },
    {
      id: "large",
      label: "Large",
      icon: "\u{1F536}",
      description: "Comfortable reading",
      width: "100%",
      height: "650px"
    },
    {
      id: "fullwidth",
      label: "Full Screen",
      icon: "\u{1F7E0}",
      description: "Full-screen document viewer",
      width: "100%",
      height: "800px"
    }
  ],
  image: [
    {
      id: "thumbnail",
      label: "Thumbnail",
      icon: "\u{1F539}",
      description: "Small preview image",
      width: "200px",
      height: "auto"
    },
    {
      id: "compact",
      label: "Compact",
      icon: "\u{1F538}",
      description: "Suitable for body content",
      width: "400px",
      height: "auto"
    },
    {
      id: "medium",
      label: "Medium",
      icon: "\u{1F536}",
      description: "Good for viewing images",
      width: "600px",
      height: "auto",
      recommended: true
    },
    {
      id: "large",
      label: "Large",
      icon: "\u{1F7E0}",
      description: "For detailed viewing",
      width: "100%",
      height: "auto"
    }
  ],
  audio: [
    {
      id: "slim",
      label: "Slim",
      icon: "\u{1F3B5}",
      description: "Minimal space",
      width: "100%",
      height: "100px",
      recommended: true
    },
    {
      id: "standard",
      label: "Standard",
      icon: "\u{1F3B6}",
      description: "With some padding",
      width: "100%",
      height: "120px"
    }
  ]
};
var SUPPORTED_FILE_TYPES = [
  // Video
  { extension: ".mp4", mimeType: "video/mp4", category: "video", icon: "\u{1F3AC}", label: "MP4 Video" },
  { extension: ".webm", mimeType: "video/webm", category: "video", icon: "\u{1F3AC}", label: "WebM Video" },
  { extension: ".mov", mimeType: "video/quicktime", category: "video", icon: "\u{1F3AC}", label: "QuickTime Video" },
  { extension: ".avi", mimeType: "video/x-msvideo", category: "video", icon: "\u{1F3AC}", label: "AVI Video" },
  // Audio
  { extension: ".mp3", mimeType: "audio/mpeg", category: "audio", icon: "\u{1F3B5}", label: "MP3 Audio" },
  { extension: ".wav", mimeType: "audio/wav", category: "audio", icon: "\u{1F3B5}", label: "WAV Audio" },
  { extension: ".ogg", mimeType: "audio/ogg", category: "audio", icon: "\u{1F3B5}", label: "OGG Audio" },
  { extension: ".m4a", mimeType: "audio/mp4", category: "audio", icon: "\u{1F3B5}", label: "M4A Audio" },
  // Document
  { extension: ".pdf", mimeType: "application/pdf", category: "document", icon: "\u{1F4C4}", label: "PDF Document" },
  // Image
  { extension: ".jpg", mimeType: "image/jpeg", category: "image", icon: "\u{1F5BC}\uFE0F", label: "JPEG Image" },
  { extension: ".jpeg", mimeType: "image/jpeg", category: "image", icon: "\u{1F5BC}\uFE0F", label: "JPEG Image" },
  { extension: ".png", mimeType: "image/png", category: "image", icon: "\u{1F5BC}\uFE0F", label: "PNG Image" },
  { extension: ".gif", mimeType: "image/gif", category: "image", icon: "\u{1F5BC}\uFE0F", label: "GIF Image" },
  { extension: ".webp", mimeType: "image/webp", category: "image", icon: "\u{1F5BC}\uFE0F", label: "WebP Image" },
  { extension: ".svg", mimeType: "image/svg+xml", category: "image", icon: "\u{1F5BC}\uFE0F", label: "SVG Image" }
];
function getFileTypeInfo(fileName) {
  const ext = fileName.toLowerCase().substring(fileName.lastIndexOf("."));
  return SUPPORTED_FILE_TYPES.find((ft) => ft.extension === ext) || null;
}
function getSizePresets(category) {
  return SIZE_PRESETS[category] || SIZE_PRESETS.document;
}
function getRecommendedSize(category) {
  const presets = getSizePresets(category);
  return presets.find((p) => p.recommended) || presets[0];
}
var SUPPORTED_EXTENSIONS = SUPPORTED_FILE_TYPES.map((ft) => ft.extension);

// src/upload-modal.ts
var UploadModal = class extends import_obsidian3.Modal {
  constructor(app, uploader, driveFolder, defaultShowTitle, onComplete) {
    super(app);
    this.selectedFile = null;
    this.selectedSize = null;
    this.fileCategory = null;
    this.showTitle = true;
    // UI Elements
    this.fileInputEl = null;
    this.fileInfoEl = null;
    this.sizeOptionsEl = null;
    this.progressEl = null;
    this.uploadBtn = null;
    this.uploader = uploader;
    this.driveFolder = driveFolder;
    this.showTitle = defaultShowTitle;
    this.onComplete = onComplete;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("drive-embedder-modal");
    contentEl.createEl("h2", {
      text: "\u{1F4C1} Drive Embedder",
      cls: "drive-embedder-title"
    });
    contentEl.createEl("p", {
      text: "Upload files to Google Drive and generate embed code.",
      cls: "drive-embedder-subtitle"
    });
    this.createFileSection(contentEl);
    this.fileInfoEl = contentEl.createDiv({ cls: "drive-embedder-file-info hidden" });
    this.sizeOptionsEl = contentEl.createDiv({ cls: "drive-embedder-size-options hidden" });
    this.createTitleToggle(contentEl);
    this.progressEl = contentEl.createDiv({ cls: "drive-embedder-progress hidden" });
    this.createActionButtons(contentEl);
    this.createSupportedFormatsInfo(contentEl);
  }
  createFileSection(container) {
    const section = container.createDiv({ cls: "drive-embedder-section" });
    this.fileInputEl = section.createEl("input", {
      type: "file",
      cls: "drive-embedder-file-input"
    });
    this.fileInputEl.accept = SUPPORTED_EXTENSIONS.join(",");
    this.fileInputEl.addEventListener("change", (e) => this.handleFileSelect(e));
    const dropZone = section.createDiv({ cls: "drive-embedder-dropzone" });
    dropZone.innerHTML = `
            <div class="dropzone-content">
                <span class="dropzone-icon">\u{1F4C2}</span>
                <p class="dropzone-text">Drag files here or</p>
                <button class="dropzone-btn">Select File</button>
            </div>
        `;
    const selectBtn = dropZone.querySelector(".dropzone-btn");
    selectBtn == null ? void 0 : selectBtn.addEventListener("click", () => {
      var _a;
      return (_a = this.fileInputEl) == null ? void 0 : _a.click();
    });
    dropZone.addEventListener("dragover", (e) => {
      e.preventDefault();
      dropZone.addClass("dragover");
    });
    dropZone.addEventListener("dragleave", () => {
      dropZone.removeClass("dragover");
    });
    dropZone.addEventListener("drop", (e) => {
      var _a;
      e.preventDefault();
      dropZone.removeClass("dragover");
      const files = (_a = e.dataTransfer) == null ? void 0 : _a.files;
      if (files && files.length > 0) {
        this.processFile(files[0]);
      }
    });
  }
  handleFileSelect(e) {
    var _a;
    const input = e.target;
    const file = (_a = input.files) == null ? void 0 : _a[0];
    if (file) {
      this.processFile(file);
    }
  }
  processFile(file) {
    const fileInfo = getFileTypeInfo(file.name);
    if (!fileInfo) {
      new import_obsidian3.Notice("Unsupported file type.");
      return;
    }
    this.selectedFile = file;
    this.fileCategory = fileInfo.category;
    this.updateFileInfo(file, fileInfo);
    this.updateSizeOptions(fileInfo.category);
    if (this.uploadBtn) {
      this.uploadBtn.disabled = false;
    }
  }
  updateFileInfo(file, fileInfo) {
    if (!this.fileInfoEl)
      return;
    this.fileInfoEl.empty();
    this.fileInfoEl.removeClass("hidden");
    const infoCard = this.fileInfoEl.createDiv({ cls: "file-info-card" });
    const fileHeader = infoCard.createDiv({ cls: "file-header" });
    fileHeader.createSpan({ text: fileInfo.icon, cls: "file-icon" });
    fileHeader.createSpan({ text: file.name, cls: "file-name" });
    const fileDetails = infoCard.createDiv({ cls: "file-details" });
    fileDetails.createSpan({ text: `Type: ${fileInfo.label}`, cls: "file-type" });
    fileDetails.createSpan({ text: `Size: ${this.formatFileSize(file.size)}`, cls: "file-size" });
  }
  updateSizeOptions(category) {
    if (!this.sizeOptionsEl)
      return;
    this.sizeOptionsEl.empty();
    this.sizeOptionsEl.removeClass("hidden");
    const presets = getSizePresets(category);
    const recommended = getRecommendedSize(category);
    this.sizeOptionsEl.createEl("h4", {
      text: "\u{1F4D0} Select Embed Size",
      cls: "size-section-title"
    });
    const optionsGrid = this.sizeOptionsEl.createDiv({ cls: "size-options-grid" });
    presets.forEach((preset) => {
      const option = optionsGrid.createDiv({
        cls: `size-option ${preset.id === (recommended == null ? void 0 : recommended.id) ? "recommended" : ""}`
      });
      option.innerHTML = `
                <span class="size-icon">${preset.icon}</span>
                <span class="size-label">${preset.label}</span>
                <span class="size-desc">${preset.description}</span>
                ${preset.recommended ? '<span class="recommended-badge">Recommended</span>' : ""}
            `;
      if (preset.id === (recommended == null ? void 0 : recommended.id)) {
        option.addClass("selected");
        this.selectedSize = preset;
      }
      option.addEventListener("click", () => {
        optionsGrid.querySelectorAll(".size-option").forEach(
          (el) => el.removeClass("selected")
        );
        option.addClass("selected");
        this.selectedSize = preset;
      });
    });
  }
  createTitleToggle(container) {
    const toggleSection = container.createDiv({ cls: "drive-embedder-toggle-section" });
    new import_obsidian3.Setting(toggleSection).setName("Show filename").setDesc("Display filename above the embed").addToggle(
      (toggle) => toggle.setValue(this.showTitle).onChange((value) => {
        this.showTitle = value;
      })
    );
  }
  createActionButtons(container) {
    const buttonContainer = container.createDiv({ cls: "drive-embedder-buttons" });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "drive-embedder-btn cancel"
    });
    cancelBtn.addEventListener("click", () => this.close());
    this.uploadBtn = buttonContainer.createEl("button", {
      text: "\u{1F4E4} Upload & Embed",
      cls: "drive-embedder-btn primary"
    });
    this.uploadBtn.disabled = true;
    this.uploadBtn.addEventListener("click", () => this.handleUpload());
  }
  createSupportedFormatsInfo(container) {
    const infoSection = container.createDiv({ cls: "drive-embedder-formats-info" });
    infoSection.innerHTML = `
            <details>
                <summary>Supported File Formats</summary>
                <div class="formats-grid">
                    <div class="format-group">
                        <span class="format-icon">\u{1F3AC}</span>
                        <span class="format-label">Video</span>
                        <span class="format-types">MP4, WebM, MOV, AVI</span>
                    </div>
                    <div class="format-group">
                        <span class="format-icon">\u{1F3B5}</span>
                        <span class="format-label">Audio</span>
                        <span class="format-types">MP3, WAV, OGG, M4A</span>
                    </div>
                    <div class="format-group">
                        <span class="format-icon">\u{1F4C4}</span>
                        <span class="format-label">Document</span>
                        <span class="format-types">PDF</span>
                    </div>
                    <div class="format-group">
                        <span class="format-icon">\u{1F5BC}\uFE0F</span>
                        <span class="format-label">Image</span>
                        <span class="format-types">JPG, PNG, GIF, WebP, SVG</span>
                    </div>
                </div>
            </details>
        `;
  }
  async handleUpload() {
    if (!this.selectedFile || !this.selectedSize) {
      new import_obsidian3.Notice("Please select a file and size.");
      return;
    }
    if (this.uploadBtn) {
      this.uploadBtn.disabled = true;
      this.uploadBtn.textContent = "Uploading...";
    }
    this.showProgress();
    try {
      const result = await this.uploader.uploadFile(
        this.selectedFile,
        this.driveFolder,
        (progress) => this.updateProgress(progress)
      );
      if (!result) {
        throw new Error("Failed to receive upload result.");
      }
      new import_obsidian3.Notice("\u2705 Upload complete! Embed code generated.");
      this.onComplete({
        file: this.selectedFile,
        uploadResult: result,
        embedOptions: {
          size: this.selectedSize,
          showTitle: this.showTitle
        }
      });
      this.close();
    } catch (error) {
      console.error("Upload failed:", error);
      new import_obsidian3.Notice(`\u274C Upload failed: ${error.message}`);
      if (this.uploadBtn) {
        this.uploadBtn.disabled = false;
        this.uploadBtn.textContent = "\u{1F4E4} Upload & Embed";
      }
      this.hideProgress();
    }
  }
  showProgress() {
    if (!this.progressEl)
      return;
    this.progressEl.empty();
    this.progressEl.removeClass("hidden");
    this.progressEl.innerHTML = `
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 0%"></div>
                </div>
                <div class="progress-text">
                    <span class="progress-status">Preparing...</span>
                    <span class="progress-percent">0%</span>
                </div>
            </div>
        `;
  }
  updateProgress(progress) {
    if (!this.progressEl)
      return;
    const fillEl = this.progressEl.querySelector(".progress-fill");
    const statusEl = this.progressEl.querySelector(".progress-status");
    const percentEl = this.progressEl.querySelector(".progress-percent");
    if (fillEl) {
      fillEl.style.width = `${progress.progress}%`;
    }
    if (statusEl) {
      statusEl.textContent = progress.message;
    }
    if (percentEl) {
      percentEl.textContent = `${Math.round(progress.progress)}%`;
    }
  }
  hideProgress() {
    if (this.progressEl) {
      this.progressEl.addClass("hidden");
    }
  }
  formatFileSize(bytes) {
    if (bytes === 0)
      return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/embed-generator.ts
var EmbedGenerator = class {
  /**
   * Generate embed code for a file uploaded to Google Drive
   */
  generateEmbed(fileName, uploadResult, options) {
    const fileInfo = getFileTypeInfo(fileName);
    const { size, showTitle } = options;
    let embedCode = "";
    if (showTitle) {
      embedCode += `**\u{1F4C1} ${fileName}**

`;
    }
    if (!fileInfo) {
      embedCode += this.generateGenericEmbed(uploadResult);
      return embedCode;
    }
    switch (fileInfo.category) {
      case "video":
        embedCode += this.generateVideoEmbed(uploadResult, size);
        break;
      case "audio":
        embedCode += this.generateAudioEmbed(uploadResult, size);
        break;
      case "document":
        embedCode += this.generateDocumentEmbed(uploadResult, size);
        break;
      case "image":
        embedCode += this.generateImageEmbed(uploadResult, size, fileName);
        break;
      default:
        embedCode += this.generateGenericEmbed(uploadResult);
    }
    return embedCode;
  }
  /**
   * Generate video embed (iframe with Google Drive player)
   * Using /preview URL ensures compatibility with all file sizes
   * and leverages Google's built-in video player
   */
  generateVideoEmbed(result, size) {
    const previewUrl = `https://drive.google.com/file/d/${result.fileId}/preview`;
    return `<div style="width: ${size.width}; margin: 0 auto;">
<iframe
    src="${previewUrl}"
    width="100%"
    height="${size.height}"
    frameborder="0"
    allow="autoplay; encrypted-media"
    allowfullscreen
    style="border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); background-color: #000;">
</iframe>
</div>`;
  }
  /**
   * Generate audio embed (iframe with Google Drive player)
   * Using /preview URL ensures compatibility with all file sizes
   */
  generateAudioEmbed(result, size) {
    const previewUrl = `https://drive.google.com/file/d/${result.fileId}/preview`;
    return `<div style="width: ${size.width}; margin: 0 auto;">
<iframe
    src="${previewUrl}"
    width="100%"
    height="${size.height}"
    frameborder="0"
    allow="autoplay; encrypted-media"
    style="border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
</iframe>
</div>`;
  }
  /**
   * Generate document embed (iframe for PDF viewer)
   */
  generateDocumentEmbed(result, size) {
    const previewUrl = `https://drive.google.com/file/d/${result.fileId}/preview`;
    return `<div style="width: ${size.width}; margin: 0 auto;">
<iframe
    src="${previewUrl}"
    width="100%"
    height="${size.height}"
    frameborder="0"
    style="border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);">
</iframe>
</div>`;
  }
  /**
   * Generate image embed (direct image with thumbnail URL)
   */
  generateImageEmbed(result, size, fileName) {
    const thumbnailUrl = `https://drive.google.com/thumbnail?id=${result.fileId}&sz=w1000`;
    const viewUrl = result.webViewLink;
    return `<div style="width: ${size.width}; margin: 0 auto; text-align: center;">
<a href="${viewUrl}" target="_blank">
<img
    src="${thumbnailUrl}"
    alt="${fileName}"
    style="max-width: 100%; height: ${size.height}; object-fit: contain; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer;"
/>
</a>
</div>`;
  }
  /**
   * Generate generic embed (link only)
   */
  generateGenericEmbed(result) {
    return `[\u{1F4CE} Open File](${result.webViewLink})`;
  }
  /**
   * Generate markdown link format
   */
  generateMarkdownLink(fileName, result) {
    return `[${fileName}](${result.webViewLink})`;
  }
  /**
   * Generate all embed formats for user to choose
   */
  generateAllFormats(fileName, uploadResult, options) {
    return {
      embed: this.generateEmbed(fileName, uploadResult, options),
      link: this.generateMarkdownLink(fileName, uploadResult),
      directLink: uploadResult.webViewLink
    };
  }
};

// main.ts
var DriveEmbedderPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.oauthFlow = null;
    this.uploader = null;
  }
  async onload() {
    await this.loadSettings();
    this.embedGenerator = new EmbedGenerator();
    this.initializeServices();
    this.addRibbonIcon("cloud-upload", "Drive Embedder: Upload File", () => {
      this.openUploadModal();
    });
    this.addCommand({
      id: "upload-and-embed",
      name: "Upload File & Embed",
      editorCallback: (editor, view) => {
        this.openUploadModal(editor);
      }
    });
    this.addSettingTab(new DriveEmbedderSettingTab(this.app, this));
    console.log("Drive Embedder loaded");
  }
  onunload() {
    console.log("Drive Embedder unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.initializeServices();
  }
  initializeServices() {
    if (this.settings.googleClientId && this.settings.googleClientSecret) {
      this.oauthFlow = new GoogleOAuthFlow({
        clientId: this.settings.googleClientId,
        clientSecret: this.settings.googleClientSecret,
        redirectPort: 8586
      });
      if (this.settings.googleAccessToken) {
        this.uploader = new GoogleDriveUploader({
          clientId: this.settings.googleClientId,
          clientSecret: this.settings.googleClientSecret,
          accessToken: this.settings.googleAccessToken,
          refreshToken: this.settings.googleRefreshToken,
          tokenExpiresAt: this.settings.tokenExpiresAt,
          onTokenRefresh: async (tokens) => {
            this.settings.googleAccessToken = tokens.accessToken;
            this.settings.googleRefreshToken = tokens.refreshToken;
            this.settings.tokenExpiresAt = tokens.expiresAt;
            await this.saveSettings();
          }
        });
      }
    }
  }
  async startOAuthFlow() {
    if (!this.oauthFlow) {
      new import_obsidian4.Notice("Please enter Google OAuth settings first.");
      return false;
    }
    try {
      const tokens = await this.oauthFlow.startOAuthFlow();
      this.settings.googleAccessToken = tokens.accessToken;
      this.settings.googleRefreshToken = tokens.refreshToken;
      this.settings.tokenExpiresAt = tokens.expiresAt;
      await this.saveSettings();
      new import_obsidian4.Notice("\u2705 Google Drive connected successfully!");
      return true;
    } catch (error) {
      console.error("OAuth flow failed:", error);
      new import_obsidian4.Notice(`\u274C Connection failed: ${error.message}`);
      return false;
    }
  }
  async disconnectGoogleDrive() {
    this.settings.googleAccessToken = "";
    this.settings.googleRefreshToken = "";
    this.settings.tokenExpiresAt = 0;
    this.uploader = null;
    await this.saveSettings();
    new import_obsidian4.Notice("Google Drive disconnected.");
  }
  isConnected() {
    return !!this.settings.googleAccessToken && !!this.uploader;
  }
  openUploadModal(editor) {
    if (!this.isConnected()) {
      new import_obsidian4.Notice("Please connect to Google Drive first. (Connect in settings)");
      return;
    }
    if (!this.uploader) {
      new import_obsidian4.Notice("Uploader initialization failed. Please check settings.");
      return;
    }
    new UploadModal(
      this.app,
      this.uploader,
      this.settings.driveFolder,
      this.settings.showTitleByDefault,
      async (result) => {
        const embedCode = this.embedGenerator.generateEmbed(
          result.file.name,
          result.uploadResult,
          result.embedOptions
        );
        if (editor) {
          editor.replaceSelection(embedCode);
        } else {
          await navigator.clipboard.writeText(embedCode);
          new import_obsidian4.Notice("\u{1F4CB} Embed code copied to clipboard!");
        }
      }
    ).open();
  }
};
var DriveEmbedderSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Drive Embedder Settings" });
    this.createConnectionSection(containerEl);
    this.createOAuthSection(containerEl);
    this.createDriveSection(containerEl);
    this.createEmbedSection(containerEl);
    this.createHelpSection(containerEl);
  }
  createConnectionSection(containerEl) {
    const connectionDiv = containerEl.createDiv({ cls: "drive-embedder-connection-section" });
    const isConnected = this.plugin.isConnected();
    connectionDiv.createEl("h3", { text: "Connection Status" });
    const statusDiv = connectionDiv.createDiv({ cls: "connection-status" });
    statusDiv.innerHTML = isConnected ? '<span class="status-connected">\u2705 Google Drive Connected</span>' : '<span class="status-disconnected">\u274C Not Connected</span>';
    if (isConnected) {
      new import_obsidian4.Setting(connectionDiv).setName("Disconnect").setDesc("Disconnect from Google Drive").addButton(
        (button) => button.setButtonText("Disconnect").setWarning().onClick(async () => {
          await this.plugin.disconnectGoogleDrive();
          this.display();
        })
      );
    } else {
      new import_obsidian4.Setting(connectionDiv).setName("Connect to Google Drive").setDesc("Enter OAuth settings below, then click the Connect button").addButton(
        (button) => button.setButtonText("Connect").setCta().onClick(async () => {
          const success = await this.plugin.startOAuthFlow();
          if (success) {
            this.display();
          }
        })
      );
    }
  }
  createOAuthSection(containerEl) {
    containerEl.createEl("h3", { text: "Google OAuth Settings" });
    new import_obsidian4.Setting(containerEl).setName("Client ID").setDesc("OAuth Client ID generated from Google Cloud Console").addText(
      (text) => text.setPlaceholder("xxx.apps.googleusercontent.com").setValue(this.plugin.settings.googleClientId).onChange(async (value) => {
        this.plugin.settings.googleClientId = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Client Secret").setDesc("OAuth Client Secret generated from Google Cloud Console").addText(
      (text) => text.setPlaceholder("GOCSPX-...").setValue(this.plugin.settings.googleClientSecret).onChange(async (value) => {
        this.plugin.settings.googleClientSecret = value;
        await this.plugin.saveSettings();
      })
    );
  }
  createDriveSection(containerEl) {
    containerEl.createEl("h3", { text: "Google Drive Settings" });
    new import_obsidian4.Setting(containerEl).setName("Upload Folder").setDesc("Google Drive folder path for uploaded files").addText(
      (text) => text.setPlaceholder("Obsidian/DriveEmbedder").setValue(this.plugin.settings.driveFolder).onChange(async (value) => {
        this.plugin.settings.driveFolder = value;
        await this.plugin.saveSettings();
      })
    );
  }
  createEmbedSection(containerEl) {
    containerEl.createEl("h3", { text: "Embed Settings" });
    new import_obsidian4.Setting(containerEl).setName("Show Filename by Default").setDesc("Display filename in embed code by default").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showTitleByDefault).onChange(async (value) => {
        this.plugin.settings.showTitleByDefault = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Default Theme").setDesc("Default embed theme (auto-detects system theme)").addDropdown(
      (dropdown) => dropdown.addOption("auto", "Auto (System Theme)").addOption("light", "Light").addOption("dark", "Dark").setValue(this.plugin.settings.defaultTheme).onChange(async (value) => {
        this.plugin.settings.defaultTheme = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h4", { text: "Default Embed Size" });
    new import_obsidian4.Setting(containerEl).setName("Default Video Size").addDropdown(
      (dropdown) => dropdown.addOption("compact", "Compact").addOption("medium", "Medium").addOption("large", "Large").addOption("fullwidth", "Full Width").setValue(this.plugin.settings.defaultVideoSize).onChange(async (value) => {
        this.plugin.settings.defaultVideoSize = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Default Audio Size").addDropdown(
      (dropdown) => dropdown.addOption("slim", "Slim").addOption("standard", "Standard").setValue(this.plugin.settings.defaultAudioSize).onChange(async (value) => {
        this.plugin.settings.defaultAudioSize = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Default Document Size").addDropdown(
      (dropdown) => dropdown.addOption("compact", "Compact").addOption("medium", "Medium").addOption("large", "Large").addOption("fullheight", "Full Height").setValue(this.plugin.settings.defaultDocumentSize).onChange(async (value) => {
        this.plugin.settings.defaultDocumentSize = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Default Image Size").addDropdown(
      (dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").addOption("original", "Original Size").setValue(this.plugin.settings.defaultImageSize).onChange(async (value) => {
        this.plugin.settings.defaultImageSize = value;
        await this.plugin.saveSettings();
      })
    );
  }
  createHelpSection(containerEl) {
    containerEl.createEl("h3", { text: "Help" });
    const helpDiv = containerEl.createDiv({ cls: "drive-embedder-help" });
    helpDiv.innerHTML = `
            <details>
                <summary><strong>\u{1F4CB} How to Set Up Google OAuth</strong></summary>
                <ol>
                    <li>Go to <a href="https://console.cloud.google.com" target="_blank">Google Cloud Console</a></li>
                    <li>Create a new project or select an existing one</li>
                    <li>Go to APIs & Services \u2192 OAuth consent screen and configure</li>
                    <li>Go to APIs & Services \u2192 Credentials \u2192 Create Credentials \u2192 OAuth Client ID</li>
                    <li>Select Application type: Desktop app</li>
                    <li>Enter the generated Client ID and Client Secret in the settings above</li>
                    <li>Enable Google Drive API</li>
                </ol>
            </details>

            <details>
                <summary><strong>\u{1F3AC} Supported File Formats</strong></summary>
                <ul>
                    <li><strong>Video:</strong> MP4, WebM, MOV, AVI</li>
                    <li><strong>Audio:</strong> MP3, WAV, OGG, M4A</li>
                    <li><strong>Document:</strong> PDF</li>
                    <li><strong>Image:</strong> JPG, PNG, GIF, WebP, SVG</li>
                </ul>
            </details>

            <details>
                <summary><strong>\u{1F4D0} Embed Size Guide</strong></summary>
                <ul>
                    <li><strong>Compact:</strong> Good size for inline content</li>
                    <li><strong>Medium:</strong> Suitable for general viewing (Recommended)</li>
                    <li><strong>Large:</strong> When detailed view is needed</li>
                    <li><strong>Full Width:</strong> Immersive full-width display</li>
                </ul>
            </details>

            <details>
                <summary><strong>\u{1F517} How to Use</strong></summary>
                <ol>
                    <li>Click the cloud icon in the sidebar or search "Drive Embedder" in the command palette</li>
                    <li>Select a file (drag & drop or use the file picker button)</li>
                    <li>Choose your desired embed size</li>
                    <li>Click the "Upload & Embed" button</li>
                    <li>The embed code will be automatically inserted after upload</li>
                </ol>
            </details>
        `;
  }
};
